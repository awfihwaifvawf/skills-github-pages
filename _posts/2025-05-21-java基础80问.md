# 1.一个".java"源文件中是否可以包括多个类（不是内部类）？有什么限制？

我的回答：*可以*

```
可以，但只能有一个public的类，并且public的类名必须与文件名相一致
```

# 2.Java有没有goto?

我的回答：*~~有但是暂时没有用到~~*

```
没有，但是 goto 是 java 中的保留字。
```

# 3.说说&和&&的区别

我的回答：*~~&代表运算符与的意思，&&代表逻辑运算符并的意思~~*

```
&运算符号 （与运算）
逻辑判断符号（代表并且的意思）

&和&&都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。

&&还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式，例如，对于if(str != null && !str.equals(“”))表达式，当str为null时，后面的表达式不会执行，所以不会出现NullPointerException如果将&&改为&，则会抛出NullPointerException异常。If(x==33 & ++y>0) y会增长，If(x==33 && ++y>0)不会增长

&还可以用作位运算符，当&操作符两边的表达式不是boolean类型时，&表示按位与操作，我们通常使用0x0f来与一个整数进行&运算，来获取该整数的最低4个bit位，例如，0x31 & 0x0f的结果为0x01。
```

# 4.在JAVA中如何跳出当前的多重嵌套循环？

我的回答：break ~~contine~~

```
在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。例如，

    ok:
    for (int i = 0; i < 10; i++) {
        for (int j = 0; j < 10; j++) {
            System.out.println("i=" + i + ",j=" + j);
            if (j == 5) break ok;
        }
    }
    
另外，可以不使用标号这种方式，而是让外层的循环条件表达式的结果可以受到里层循环体代码的控制，例如，要在二维数组中查找到某个数字。

    int[][] arr = {{1, 2, 3}, {4, 5, 6, 7}, {9}};
    boolean found = false;
    for (int i = 0; i < arr.length && !found; i++) {
        for (int j = 0; j < arr[i].length; j++) {
            System.out.println("i = " + i + ", j = " + j);
            if (arr[i][j] == 5) {
                found = true;
                break;
            }
        }
    }

敲黑板：建议使用第二种，第一种已经被业界淘汰了。
```



# 5.switch语句能否作用在byte上，能否作用在long上，能否作用在String上?

我的回答：~~可以，只要不为空即可~~

```
在switch（expr1）中，expr1只能是一个整数表达式或者枚举常量（更大字体），整数表达式可以是int基本类型或Integer包装类型，由于，byte,short,char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的。

switch 不支持 long 类型；从 java1.7开始 switch 开始支持 String，这是 Java 的语法糖。
```

# 6.short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?

我的回答：~~unknow~~

```
对于short s1 = 1; s1 = s1 + 1; 由于s1+1运算时会自动提升表达式的类型，所以结果是int型，再赋值给short类型s1时，编译器将报告需要强制转换类型的错误。

对于short s1 = 1; s1 += 1;由于 += 是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。
```

# 7.char型变量中能不能存贮一个中文汉字?为什么?

我的回答：能 ~~不知道~~

```
char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字。补充说明：unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。
```

# 8.用最有效率的方法算出2乘以8等于几?

我的回答：~~2^4~~

```
2 << 3。因为将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8只要将其左移3位即可，而位运算cpu直接支持的，效率最高，所以，2乘以8等於几的最效率的方法是2 << 3。
```

# 9.请设计一个一百亿的计算器

我的回答：~~不会~~

# 10.使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？

我的回答：~~对象不能变~~

```

使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。例如，对于如下语句：

final StringBuffer a=new StringBuffer("immutable");
    
执行如下语句将报告编译期错误：

a=new StringBuffer("");

但是，执行如下语句则可以通过编译：

a.append(" broken!");

有人在定义方法的参数时，可能想采用如下形式来阻止方法内部修改传进来的参数对象：

public void method(final StringBuffer param){}

实际上，这是办不到的，在该方法内部仍然可以增加如下代码来修改参数对象：

param.append("a");

```

# 11."=="和equals方法究竟有什么区别？

我的回答：==代表值比较，equals是对象比较



```
==操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存储的数值是否相同，要比较两个基本类型的数据或两个引用变量是否相等，只能用==操作符。

如果一个变量指向的数据是对象类型的，那么，这时候涉及了两块内存，对象本身占用一块内存（堆内存），变量也占用一块内存，例如Objet obj = new Object();变量obj是一个内存，new Object()是另一个内存，此时，变量obj所对应的内存中存储的数值就是对象占用的那块内存的首地址。对于指向对象类型的变量，如果要比较两个变量是否指向同一个对象，即要看这两个变量所对应的内存中的数值是否相等，这时候就需要用==操作符进行比较。

equals方法是用于比较两个独立对象的内容是否相同，就好比去比较两个人的长相是否相同，它比较的两个对象是独立的。例如，对于下面的代码：

String a=new String("foo");
String b=new String("foo");

两条new语句创建了两个对象，然后用a,b这两个变量分别指向了其中一个对象，这是两个不同的对象，它们的首地址是不同的，即a和b中存储的数值是不相同的，所以，表达式a==b将返回false，而这两个对象中的内容是相同的，所以，表达式a.equals(b)将返回true。

在实际开发中，我们经常要比较传递进行来的字符串内容是否等，例如，String input = input.equals(“quit”)，许多人稍不注意就使用==进行比较了，这是错误的，随便从网上找几个项目实战的教学视频看看，里面就有大量这样的错误。记住，字符串的比较基本上都是使用equals方法。

如果一个类没有自己定义equals方法，那么它将继承Object类的equals方法，Object类的equals方法的实现代码如下：

boolean equals(Object o){
return this==o;
}

这说明，如果一个类没有自己定义equals方法，它默认的equals方法（从Object 类继承的）就是使用==操作符，也是在比较两个变量指向的对象是否是同一对象，这时候使用equals和使用==会得到同样的结果，如果比较的是两个独立的对象则总返回false。如果你编写的类希望能够比较该类创建的两个实例对象的内容是否相同，那么你必须覆盖equals方法，由你自己写代码来决定在什么情况即可认为两个对象的内容是相同的。
```



# 12.静态变量和实例变量的区别？

我的回答：静态变量是类变量，可以被每一个对象使用 实例变量是对象变量，~~不能被其他对象使用~~

```


在语法定义上的区别：静态变量前要加static关键字，而实例变量前则不加。

在程序运行时的区别：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。

例如，对于下面的程序，无论创建多少个实例对象，永远都只分配了一个staticVar变量，并且每创建一个实例对象，这个staticVar就会加1；但是，每创建一个实例对象，就会分配一个instanceVar，即可能分配多个instanceVar，并且每个instanceVar的值都只自加了1次。

public class VariantTest {
    public static int staticVar = 0;
    public int instanceVar = 0;

    public VariantTest() {
        staticVar++;
        instanceVar++;
        System.out.println("staticVar=" + staticVar + ",instanceVar=" + instanceVar);
    }
}
```

# 13.是否可以从一个static方法内部发出对非static方法的调用？

我的回答：可以

```
因为非static方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调用，而static方法调用时不需要创建对象，可以直接调用。也就是说，当一个static方法被调用时，可能还没有创建任何实例对象，如果从一个static方法中发出对非static方法的调用，那个非static方法是关联到哪个对象上的呢？这个逻辑无法成立，所以，一个static方法内部发出对非static方法的调用。
```

# 14.Integer与int的区别

我的回答：一个是包装类，一个是基础类

```
int是java提供的8种原始数据类型之一。Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。int的默认值为0，而Integer的默认值为null，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况，例如，要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer。在JSP开发中，Integer的默认为null，所以用el表达式在文本框中显示时，值为空白字符串，而int默认的默认值为0，所以用el表达式在文本框中显示时，结果为0，所以，int不适合作为web层的表单数据的类型。

在Hibernate中，如果将OID定义为Integer类型，那么Hibernate就可以根据其值是否为null而判断一个对象是否是临时的，如果将OID定义为了int类型，还需要在hbm映射文件中设置其unsaved-value属性为0。

另外，Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量。
```

# 15.Math.round(11.5)等于多少? Math.round(-11.5)等于多少?

我的回答：12   ~~-12~~

```
12  11 
Math类中提供了三个与取整有关的方法：ceil、floor、round，这些方法的作用与它们的英文名称的含义相对应，例如，ceil的英文意义是天花板，该方法就表示向上取整，Math.ceil(11.3)的结果为12,Math.ceil(-11.3)的结果是-11；floor的英文意义是地板，该方法就表示向下取整，Math.floor(11.6)的结果为11,Math.floor(-11.6)的结果是-12；最难掌握的是round方法，它表示“四舍五入”，算法为Math.floor(x+0.5)，即将原来的数字加上0.5后再向下取整，所以，Math.round(11.5)的结果为12，Math.round(-11.5)的结果为-11。
```

# 16.请说出作用域public，private，protected，以及不写时的区别

我的回答：public，所有包可用 private，只有自己类可用 protected，只有自己包可用

这四个作用域的可见范围如下表所示。

说明：如果在修饰的元素上面没有写任何访问修饰符，则表示friendly。

| 作用域         | 当前类 | 同一package | 子孙类 | 其他package |
| -------------- | ------ | ----------- | ------ | ----------- |
| public 公共    | √      | √           | √      | √           |
| protected 保护 | √      | √           | √      | ×           |
| friendly 友好  | √      | √           | ×      | ×           |
| private 私人   | √      | ×           | ×      | ×           |

备注：只要记住了有4种访问权限，4个访问范围，然后将全选和范围在水平和垂直方向上分别按排从小到大或从大到小的顺序排列，就很容易画出上面的图了。

# 17.Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型?

我的回答：重写和重载 重载可以与父方法的入参数不同 重写参数必须相同

```

Overload是重载的意思，Override是覆盖的意思，也就是重写。

重载Overload表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。

重写Override表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。子类覆盖父类的方法时，只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常，因为子类可以解决父类的一些问题，不能比父类有更多的问题。子类方法的访问权限只能比父类的更大，不能更小。如果父类的方法是private类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法。

至于Overloaded的方法是否可以改变返回值的类型这个问题，要看你倒底想问什么呢？这个题目很模糊。如果几个Overloaded的方法的参数列表不一样，它们的返回者类型当然也可以不一样。但我估计你想问的问题是：如果两个方法的参数列表完全一样，是否可以让它们的返回值不同来实现重载Overload。这是不行的，我们可以用反证法来说明这个问题，因为我们有时候调用一个方法时也可以不定义返回结果变量，即不要关心其返回结果，例如，我们调用map.remove(key)方法时，虽然remove方法有返回值，但是我们通常都不会定义接收返回结果的变量，这时候假设该类中有两个名称和参数列表完全相同的方法，仅仅是返回类型不同，java就无法确定编程者倒底是想调用哪个方法了，因为它无法通过返回结果类型来判断。

override可以翻译为覆盖，从字面就可以知道，它是覆盖了一个方法并且对其重写，以求达到不同的作用。对我们来说最熟悉的覆盖就是对接口方法的实现，在接口中一般只是对方法进行了声明，而我们在实现时，就需要实现接口声明的所有方法。除了这个典型的用法以外，我们在继承中也可能会在子类覆盖父类中的方法。在覆盖要注意以下的几点：

1）覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果；

2）覆盖的方法的返回值必须和被覆盖的方法的返回一致；

3）覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类；

4）被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。

overload对我们来说可能比较熟悉，可以翻译为重载，它是指我们可以定义一些名称相同的方法，通过定义不同的输入参数来区分这些方法，然后再调用时，JVM就会根据不同的参数样式，来选择合适的方法执行。在使用重载要注意以下的几点：

1）在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是fun(int,float)，但是不能为fun(int,int)）；

2）不能通过访问权限、返回类型、抛出的异常进行重载；

3）方法的异常类型和数目不会对重载造成影响；

4）对于继承来说，如果某一方法在父类中是访问权限是priavte，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。
```



# 18.构造器Constructor是否可被override?

我的回答：不行

```
构造器Constructor不能被继承，因此不能重写Override，但可以被重载Overload。
```

# 19.接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承具体类(concrete class)? 抽象类中是否可以有静态的main方法？

我的回答：不行，行，行，行

```
接口可以继承接口。抽象类可以实现(implements)接口，抽象类可以继承具体类。抽象类中可以有静态的main方法。

备注：只要明白了接口和抽象类的本质和作用，这些问题都很好回答，想想看，如果自己作为是java语言的设计者，是否会提供这样的支持，如果不提供的话，有什么理由吗？如果没有道理不提供，那答案就是肯定的了。

只有记住抽象类与普通类的唯一区别就是不能创建实例对象和允许有abstract方法。
```

20.写clone()方法时，通常都有一行代码，是什么？
我的回答：不会

```
clone 有缺省行为，super.clone();因为首先要把父类中的成员复制到位，然后才是复制自己的成员。
```

# 21.面向对象的特征有哪些方面

我的回答：封装 继承 多态

```
面向对象的编程语言有封装、继承 、抽象、多态等4个主要的特征。
```



# 22.java中实现多态的机制是什么？

我的回答：就是继承父类然后重写/重载父类的方法

```
靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。
```

# 23.abstract class和interface有什么区别?

我的回答：abstract 可以有抽象方法和普通方法

interface只能有普通方法

继承了abstract 必须实现抽象方法

继承interface不必实现抽象方法

```

1）抽象类可以有构造方法，接口中不能有构造方法。

2）抽象类中可以有普通成员变量，接口中没有普通成员变量

3）抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。

4） 抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然

eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。

5）抽象类中可以包含静态方法，接口中不能包含静态方法

6）抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。

7）一个类可以实现多个接口，但只能继承一个抽象类。
```

# 24.abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized?

我的回答： 可以

```
abstract的method 不可以是static的，因为抽象的方法是要被子类实现的，而static与子类扯不上关系！

native方法表示该方法要用另外一种依赖平台的编程语言实现的，不存在着被子类实现的问题，所以，它也不能是抽象的，不能与abstract混用。

关于synchronized与abstract合用的问题，我觉得也不行，因为在我几年的学习和开发中，从来没见到过这种情况，并且我觉得synchronized应该是作用在一个具体的方法上才有意义。而且，方法上的synchronized同步所使用的同步锁对象是this，而抽象方法上无法确定this是什么。
```

# 25.什么是内部类？Static Nested Class 和 Inner Class的不同。

我的回答： 不知到

```
内部类就是在一个类的内部定义的类，内部类中不能定义静态成员

内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，也可以定义在外部类的方法体中、
```

```
public class Outer {
    int out_x = 0;

    public void method() {
        //在方法体内部定义的内部类
        class Inner2 {
            public void method() {
                out_x = 3;
            }
        }
        Inner2 inner2 = new Inner2();
    }

    //在方法体外面定义的内部类
    public class Inner1 {

    }
}
```

```
在方法体外面定义的内部类的访问类型可以是public,protecte,默认的，private等4种类型，

创建内部类的实例对象时，一定要先创建外部类的实例对象，然后用这个外部类的实例对象去创建内部类的实例对象

在方法内部定义的内部类前面不能有访问类型修饰符，就好像方法中定义的局部变量一样，但这种内部类的前面可以使用final或abstract修饰符。这种内部类对其他类是不可见的其他类无法引用这种内部类，但是这种内部类创建的实例对象可以传递给其他类访问。这种内部类必须是先定义，后使用，即内部类的定义代码必须出现在使用该类之前，这与方法中的局部变量必须先定义后使用的道理也是一样的。这种内部类可以访问方法体中的局部变量，但是，该局部变量前必须加final修饰符。

由于static Nested Class不依赖于外部类的实例对象，所以，static Nested Class能访问外部类的非static成员变量。当在外部类中访问Static Nested Class时，可以直接使用Static Nested Class的名字，而不需要加上外部类的名字了，在Static Nested Class中也可以直接引用外部类的static的成员变量，不需要加上外部类的名字。

在静态方法中定义的内部类也是Static Nested Class，这时候不能在类前面加static关键字，静态方法中的Static Nested Class与普通方法中的内部类的应用方式很相似，它除了可以直接访问外部类中的static的成员变量，还可以访问静态方法中的局部变量，但是，该局部变量前必须加final修饰符。
```

# 26.内部类可以引用它的包含类的成员吗？有没有什么限制？

我的回答：可以引用

```
如果不是静态内部类，那没有什么限制！

如果把静态嵌套类当作内部类的一种特例，那在这种情况下不可以访问外部类的普通成员变量，而只能访问外部类中的静态成员，例如，下面的代码：
```

```
class Outer {
    static int x;

    static class Inner {
        void test() {
            syso(x);
        }
    }
}
```

# 27.Anonymous Inner Class (匿名内部类) 是否可以extends(继承)其它类，是否可以implements(实现)interface(接口)?

我的回答：不能，不能

```
可以继承其他类或实现其他接口。不仅是可以，而是必须!
```

# 28.super.getClass()方法调用 下面程序的输出结果是多少？

```
import java.util.Date;

public class Test extends Date {
	public static void main(String[] args) {
		new Test().test();
	}
	
	public void test() {
		System.out.println(super.getClass().getName());
	}
}
```

我的回答：调用父类的getClass()方法

```
在test方法中，直接调用getClass().getName()方法，返回的是Test类名。
由于getClass()在Object类中定义成了final，子类不能覆盖该方法，
所以，在test方法中调用getClass().getName()方法，
其实就是在调用从父类继承的getClass()方法，等效于调用super.getClass().getName()方法，
所以，super.getClass().getName()方法返回的也应该是Test。

如果想得到父类的名称，应该用如下代码：
getClass().getSuperClass().getName();

```

# 29.String是最基本的数据类型吗?

我的回答：不是

```
基本数据类型包括byte、int、char、long、float、double、boolean和short。
```

# 30.String s = "Hello";s = s + " world!";这两行代码执行后，原始的String对象中的内容到底变了没有？

我的回答：没有变，而是生成了一个新的对象

```
因为String被设计成不可变(immutable)类，所以它的所有对象都是不可变对象。在这段代码中，s原先指向一个String对象，内容是 "Hello"，然后我们对s进行了+操作，那么s所指向的那个对象是否发生了改变呢？答案是没有。这时，s不指向原来那个对象了，而指向了另一个 String对象，内容为"Hello world!"，原来那个对象还存在于内存之中，只是s这个引用变量不再指向它了。
```

# 31.是否可以继承String类?

我的回答：不能String是final类

# 32.String s = new String("xyz");创建了几个String Object? 二者之间有什么区别？

我的回答：一个，不知道

```
两个或一个，”xyz”对应一个对象，这个对象放在字符串常量缓冲区，常量”xyz”不管出现多少遍，都是缓冲区中的那一个。New String每写一遍，就创建一个新的对象，它一句那个常量”xyz”对象的内容来创建出一个新String对象。如果以前就用过’xyz’，这句代表就不会创建”xyz”自己了，直接从缓冲区拿。
```

# 33.String 和StringBuffer的区别

我的回答：String 每次对字符串的操作都会创建一个新的对象StringBuffer不会创建新的对象

```
JAVA平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符的字符数据。这个String类提供了数值不可改变的字符串。而这个StringBuffer类提供的字符串进行修改。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用StringBuffers来动态构造字符数据。另外，String实现了equals方法，new String(“abc”).equals(new String(“abc”)的结果为true,而StringBuffer没有实现equals方法，所以，new StringBuffer(“abc”).equals(new StringBuffer(“abc”)的结果为false。
```

# 34.如何把一段逗号分割的字符串转换成一个数组?

我的回答：split(',')

```
1. String [] result = orgStr.split(",");

2.
StringTokenizer tokener = StringTokenizer(orgStr,",");
String [] result = new String[tokener .countTokens()];
Int i=0;
while(tokener.hasNext(){result[i++]=toker.nextToken();}
```

# 35.数组有没有length()这个方法? String有没有length()这个方法？

我的回答：数组是size String有

```
数组没有length()这个方法，有length的属性。String有有length()这个方法。
```

# 36.下面这条语句一共创建了多少个对象? String s="a"+"b"+"c"+"d";

我的回答：一个

```
对于如下代码：

String s1 = "a";
String s2 = s1 + "b";
String s3 = "a" + "b";
System.out.println(s2 == "ab");
System.out.println(s3 == "ab");

第一条语句打印的结果为false，第二条语句打印的结果为true，这说明javac编译可以对字符串常量直接相加的表达式进行优化，不必要等到运行期去进行加法运算处理，而是在编译时去掉其中的加号，直接将其编译成一个这些常量相连的结果。

题目中的第一行代码被编译器在编译时优化后，相当于直接定义了一个”abcd”的字符串，所以，上面的代码应该只创建了一个String对象。写如下两行代码，

String s = "a" + "b" + "c" + "d";
System.out.println(s == "abcd");

最终打印的结果应该为true。
```

# 37.try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后?

我的回答：会被执行，再return前执行

```
但往更细地说，我的答案是在return中间执行，请看下面程序代码的运行结果：.
public class Test {

    public static void main(String[] args) {
        System.out.println(Test.test());
    }

    static int test() {
        int x = 1;
        try {
            return x;
        } finally {
            ++x;
        }
    }
}

---------执行结果 ---------
1
--------------------------
try块中有一个return语句时，紧跟在try块后的finally块中的代码仍然会被执行**‌。具体来说，当程序执行到try块中的return语句时，并不会立即返回，而是先将return语句的结果保存起来，然后执行finally块中的代码。finally块执行完毕后，再返回之前保存的结果‌12。

### finally块执行的具体过程

1.保存返回值：当try块中的return语句被执行时，程序会先将返回值保存起来，但不会立即返回。
2.执行finally块：接着程序会跳转到finally块执行其中的代码。如果在finally块中修改了返回值，这些修改不会影响try块中return语句的最终结果，因为返回值在finally块执行之前已经被保存
3.返回保存的结果：finally块执行完毕后，程序会从之前保存的位置继续返回，返回try块中保存的结果‌12。

```

# 38.下面的程序代码输出的结果是多少？

```
public class SmallT {
    public static void main(String args[]) {
        SmallT t = new SmallT();
        int b = t.get();
        System.out.println(b);
    }

    public int get() {
        try {
            return 1;
        } finally {
            return 2;
        }
    }
}
```

我的回答：2

```
try中的return语句调用的函数先于finally中调用的函数执行，也就是说return语句先执行，finally语句后执行，所以，返回的结果是2。Return并不是让函数马上返回，而是return语句执行后，将把返回结果放置进函数栈中，此时函数并不是马上返回，它要执行finally语句后才真正开始返回。
```

# 39.final, finally, finalize的区别。

我的回答： final是修饰符，finally是保留字，用于处理异常发生后最终要做的事情，finalize 不知道。

```
final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。

内部类要访问局部变量，局部变量必须定义成final类型。

finally是异常处理语句结构的一部分，表示总是执行。

finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。JVM不保证此方法总被调用
```

# 40.运行时异常与一般异常有何异同？

我的回答：允许时异常只有代码运行才会被发现，可以通过编译，一般异常无法通过编译

```
异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。
```
#41.error和exception有什么区别?
```
error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。 exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。
```
#42.Java中的异常处理机制的简单原理和应用。
我的回答：try cache 捕获异常并处理
```
异常是指java程序运行时（非编译）所发生的非正常情况或错误
java为系统异常和普通异常提供了不同的解决方案，编译器强制普通异常必须try..catch处理或用throws声明继续抛给上层调用方法处理，
所以普通异常也称为checked异常，而系统异常可以处理也可以不处理，所以，编译器不强制用try..catch处理或用throws声明，
所以系统异常也称为unchecked异常。
```
#43.请写出你最常见到的5个runtime exception。
我的回答：空指针异常，数组越界异常，oom异常，io异常，网络异常,ClassCastException
#44.java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？
我的回答：两种，实现runable接口，继承thread类 synchronized ,不知道
```
有两种实现方法，分别是继承Thread类与实现Runnable接口，用synchronized关键字修饰同步方法。
反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，
那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。
suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。
此时，其他任何线程都不能访问锁定的资源，除非被"挂起"的线程恢复运行。
对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，
而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用wait()命其进入等待状态。
若标志指出线程应当恢复，则用一个notify()重新启动线程。

```
#45.sleep() 和 wait() 有什么区别?
我的回答：sleep会在规定事件后自动进入运行状态，wait 需要调用唤醒方法来启动线程
```
sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。
调用sleep不会释放对象锁。 wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只
有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。
```
#46.同步和异步有何异同，在什么情况下分别使用他们？举例说明。
我的回答：同步会需要立刻获取方法的结果，否则主线程等待，异步不需要立刻获取运行结果，主线程会继续运行
```
当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，
在很多情况下采用异步途径往往更有效率。
```
#47.多线程有几种实现方法?同步有几种实现方法?
我的回答：不知道

多线程有两种实现方法，分别是继承Thread类与实现Runnable接口。
```
同步的实现方面有两种，分别是synchronized,wait与notify。

wait():使一个线程处于等待状态，并且释放所持有的对象的lock。

sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。

notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。

Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。
```
#48.启动一个线程是用run()还是start()？
我的回答：start
```
启动一个线程是调用start()方法，使线程就绪状态，以后可以被调度为运行状态，
一个线程必须关联一些具体的执行代码，run()方法是该线程所关联的执行代码。
```
#49.当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?
我的回答：不可以
```
分几种情况：

1）其他方法前是否加了synchronized关键字，如果没加，则能。

2）如果这个方法内部调用了wait，则可以进入其他synchronized方法。

3）如果其他个方法都加了synchronized关键字，并且内部没有调用wait，则不能。

4）如果其他方法是static，它用的同步锁是当前类的字节码，与非静态的方法不能同步，因为非静态的方法用的是this。
```

#50.线程的基本概念、线程的基本状态以及状态之间的关系。
我的回答：线程是系统运行最小单元，创建，等待，阻塞，挂起，运行，销毁
```
一个程序中可以有多条执行线索同时执行，一个线程就是程序中的一条执行线索，每个线程上都关联有要执行的代码，
即可以有多段程序代码同时运行，每个程序至少都有一个线程，即main方法执行的那个线程。
状态：就绪，运行，synchronize阻塞，wait和sleep挂起，结束。wait必须在synchronized内部调用。
调用线程的start方法后线程进入就绪状态，线程调度系统将就绪状态的线程转为运行状态，
遇到synchronized语句时，由运行状态转为阻塞，当synchronized获得锁后，由阻塞转为运行，
在这种情况可以调用wait方法转为挂起状态，当线程关联的代码执行完后，线程变为结束状态。
```
51.简述synchronized和java.util.concurrent.locks.Lock的异同 ？
我的回答：不知道
```
主要相同点：Lock能完成synchronized所实现的所有功能。
主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。
synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。Lock还有更强大的功能，例如，它的tryLock方法可以非阻塞方式去拿锁。
```
52.设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。写出程序。
我的回答：
53.子线程循环10次，接着主线程循环100，接着又回到子线程循环10次，接着再回到主线程又循环100，如此循环50次，请写出程序。
我的回答：
54.Collection框架中实现比较要实现什么接口
(我的回答：不知道)
```
comparable/comparator  可比/比较
```
#(55.ArrayList和Vector的区别)
我的回答：列表和向量的区别？不知道
```
这两个类都实现了List接口（List接口继承了Collection接口），他们都是有序集合，即存储在这两个集合中的元素的位置都是有顺序的，相当于一种动态的数组，我们以后可以按位置索引号取出某个元素，，并且其中的数据是允许重复的
同步性：
Vector（旧：Vector与Hashtable是旧的，是java一诞生就提供了的）是线程安全的，也就是说是它的方法之间是线程同步的，
而ArrayList（新：ArrayList与HashMap是java2时才提供的）是线程序不安全的，它的方法之间是线程不同步的。
如果只有一个线程会访问到集合，那最好是使用ArrayList，
因为它不考虑线程安全，效率会高些；
如果有多个线程会访问到集合，那最好是使用Vector，因为不需要我们自己再去考虑和编写线程安全的代码。
数据增长：
Vector默认增长为原来两倍 Vector还可以设置增长的空间大小
而ArrayList的增长策略 增长为原来的1.5倍 而ArrayList没有提供设置增长空间的方法。
```
56.HashMap和Hashtable的区别
我的回答：不知道
```
Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。
HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，
主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，在只有一个线程访问的情况下，效率要高于Hashtable。
```
57.List 和 Map 区别?
我的回答：list允许有重复值，map不允许，结构不一样
```
一个是存储单列数据的集合，另一个是存储键和值这样的双列数据的集合，
List中存储的数据是有顺序，并且允许重复；Map中存储的数据是没有顺序的，其键是不能重复的，它的值是可以有重复的。
```
58.List, Set, Map是否继承自Collection接口?
我的回答：是
```
List，Set是，Map不是
```
59.List、Map、Set三个接口，存取元素时，各有什么特点？
我的回答：不知道
```
首先，List与Set具有相似性，它们都是单列元素的集合，
但是set里面不允许有重复的元素，所谓重复，即不能有两个相等（注意，不是仅仅是相同）的对象
Set取元素时，没法说取第几个，只能以Iterator接口取得所有的元素，再逐一遍历各个元素。
List表示有先后顺序的集合，可以以Iterator接口取得所有的元素，再逐一遍历各个元素之外，还可以调用get(index i)来明确说明取第几个。
Map与List和Set不同，它是双列的集合，
每次存储时，要存储一对key/value，不能存储重复的key，这个重复的规则也是按equals比较相等。
```
60.说出ArrayList,Vector, LinkedList的存储性能和特性

我的回答：arrayList读写快，LinkedList增删快，Vector不知道
```
ArrayList和Vector都是使用数组方式存储数据，
此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，
但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，
Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，
而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。
```
61.去掉一个Vector集合中重复的元素
我的回答：不知道
62.Collection 和 Collections的区别。
我的回答：不知道
```
Collection是集合类的上级接口，继承与他的接口主要有Set 和List。

Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。
```
63.Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()? 它们有何区别?
我的回答：不知道
```
Set里的元素是不能重复的，元素重复与否是使用equals()方法进行判断的。

equals()和==方法决定引用值是否指向同一对象equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值。
```
64.你所知道的集合类都有哪些？主要方法？
我的回答：list Map Set 方法：add,put get length
65.两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对?
我的回答：不知道
对。
66.TreeSet里面放对象，如果同时放入了父类和子类的实例对象，那比较时使用的是父类的compareTo方法，还是使用的子类的compareTo方法，还是抛异常！
我的回答：不知道
67.说出一些常用的类，包，接口，请各举5个。

68.java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？
我的回答 IO流，字节流，字符流，IOSxxxx FileXXXXX
字节流，字符流。
字节流继承于InputStream OutputStream，字符流继承于InputStreamReader OutputStreamWriter。在java.io包中还有许多其他的流，主要是为了提高性能和使用方便。
69.字节流与字符流的区别
我的回答：不知道
字符流是字节流的包装，字符流则是直接接受字符串，它内部将串转成字节，再写入底层设备，这为我们向IO设别写入或读取字符串提供了一点点方便。
70.什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用。
我的回答：不知道
我们有时候将一个java对象变成字节流的形式传出去或者从一个字节流中恢复成一个java对象，
例如，要将java对象存储到硬盘或者传送给网络上的其他计算机，
这个过程我们可以自己写代码去把一个java对象变成某个格式的字节流再传输，
但是，jre本身就提供了这种支持，我们可以调用OutputStream的writeObject方法来做，
如果要让java 帮我们做，要被传输的对象必须实现serializable接口，
这样，javac编译时就会进行特殊处理，编译的类才可以被writeObject方法操作，这就是所谓的序列化。
需要被序列化的类必须实现Serializable接口，该接口是一个mini接口，其中没有需要实现的方法，
implements Serializable只是为了标注该对象是可被序列化的。
71.描述一下JVM加载class文件的原理机制?
我的回答：双亲委派机制，加载类时，调用父类的类加载器
JVM中类的装载是由ClassLoader和它的子类来实现的，Java ClassLoader 是一个重要的Java运行时系统组件。它负责在运行时查找和装入类文件的类。
72.heap和stack有什么区别。
我的回答：不知道
Java的内存分为两类，一类是栈内存，一类是堆内存。
栈内存是指程序进入一个方法时，会为这个方法单独分配一块私属存储空间，用于存储这个方法内部的局部变量，
当这个方法结束时，分配给这个方法的栈会释放，这个栈中的变量也将随之释放。
堆是与栈作用不同的内存，一般用于存放不放在当前方法栈中的那些数据，
例如，使用new创建的对象都放在堆里，所以，它不会随方法的结束而消失。方法中的局部变量使用final修饰后，放在堆中，而不是栈中。
73.GC是什么? 为什么要有GC?
我的回答：GC 是JAVA内存回收，避免程序随着时间的运行过程中占用的内存越来越大
GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，
忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，
Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，
Java语言没有提供释放已分配内存的显示操作方法。
74.垃圾回收的优点和原理。并考虑2种回收机制。
我的回答：避免程序随着时间的运行过程中占用的内存越来越大 标记清楚法
它使得Java程序员在编写程序的时候不再需要考虑内存管理。
垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。
垃圾回收器通常是作为一个单独的低级别的线程运行，
不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收，
程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。
回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。
75.垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？
我的回答：不知道
对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。
通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是“可达的”，
哪些对象是“不可达的”。当GC确定一些对象为“不可达”时，GC就有责任回收这些内存空间。
可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。
76.什么时候用assert。
我的回答：不知道
77.java中会存在内存泄漏吗，请简单描述。
我的回答：会
78.能不能自己写个类，也叫java.lang.String？
我的回答：可以
79.获得一个类的类对象有哪些方式？
我的回答：new 反射 clone
80.Java代码查错