# 1.一个".java"源文件中是否可以包括多个类（不是内部类）？有什么限制？

我的回答：*可以*

```
可以，但只能有一个public的类，并且public的类名必须与文件名相一致
```

# 2.Java有没有goto?

我的回答：*~~有但是暂时没有用到~~*

```
没有，但是 goto 是 java 中的保留字。
```

# 3.说说&和&&的区别

我的回答：*~~&代表运算符与的意思，&&代表逻辑运算符并的意思~~*

```
&运算符号 （与运算）
逻辑判断符号（代表并且的意思）

&和&&都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。

&&还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式，例如，对于if(str != null && !str.equals(“”))表达式，当str为null时，后面的表达式不会执行，所以不会出现NullPointerException如果将&&改为&，则会抛出NullPointerException异常。If(x==33 & ++y>0) y会增长，If(x==33 && ++y>0)不会增长

&还可以用作位运算符，当&操作符两边的表达式不是boolean类型时，&表示按位与操作，我们通常使用0x0f来与一个整数进行&运算，来获取该整数的最低4个bit位，例如，0x31 & 0x0f的结果为0x01。
```

# 4.在JAVA中如何跳出当前的多重嵌套循环？

我的回答：break ~~contine~~

```
在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。例如，

    ok:
    for (int i = 0; i < 10; i++) {
        for (int j = 0; j < 10; j++) {
            System.out.println("i=" + i + ",j=" + j);
            if (j == 5) break ok;
        }
    }
    
另外，可以不使用标号这种方式，而是让外层的循环条件表达式的结果可以受到里层循环体代码的控制，例如，要在二维数组中查找到某个数字。

    int[][] arr = {{1, 2, 3}, {4, 5, 6, 7}, {9}};
    boolean found = false;
    for (int i = 0; i < arr.length && !found; i++) {
        for (int j = 0; j < arr[i].length; j++) {
            System.out.println("i = " + i + ", j = " + j);
            if (arr[i][j] == 5) {
                found = true;
                break;
            }
        }
    }

敲黑板：建议使用第二种，第一种已经被业界淘汰了。
```



# 5.switch语句能否作用在byte上，能否作用在long上，能否作用在String上?

我的回答：~~可以，只要不为空即可~~

```
在switch（expr1）中，expr1只能是一个整数表达式或者枚举常量（更大字体），整数表达式可以是int基本类型或Integer包装类型，由于，byte,short,char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的。

switch 不支持 long 类型；从 java1.7开始 switch 开始支持 String，这是 Java 的语法糖。
```

# 6.short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?

我的回答：~~unknow~~

```
对于short s1 = 1; s1 = s1 + 1; 由于s1+1运算时会自动提升表达式的类型，所以结果是int型，再赋值给short类型s1时，编译器将报告需要强制转换类型的错误。

对于short s1 = 1; s1 += 1;由于 += 是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。
```

# 7.char型变量中能不能存贮一个中文汉字?为什么?

我的回答：能 ~~不知道~~

```
char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字。补充说明：unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。
```

# 8.用最有效率的方法算出2乘以8等于几?

我的回答：~~2^4~~

```
2 << 3。因为将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8只要将其左移3位即可，而位运算cpu直接支持的，效率最高，所以，2乘以8等於几的最效率的方法是2 << 3。
```

# 9.请设计一个一百亿的计算器

我的回答：~~不会~~

# 10.使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？

我的回答：~~对象不能变~~

```

使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。例如，对于如下语句：

final StringBuffer a=new StringBuffer("immutable");

执行如下语句将报告编译期错误：

a=new StringBuffer("");

但是，执行如下语句则可以通过编译：

a.append(" broken!");

有人在定义方法的参数时，可能想采用如下形式来阻止方法内部修改传进来的参数对象：

public void method(final StringBuffer param){}

实际上，这是办不到的，在该方法内部仍然可以增加如下代码来修改参数对象：

param.append("a");

```

# 11."=="和equals方法究竟有什么区别？

我的回答：==代表值比较，equals是对象比较



```
==操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存储的数值是否相同，要比较两个基本类型的数据或两个引用变量是否相等，只能用==操作符。

如果一个变量指向的数据是对象类型的，那么，这时候涉及了两块内存，对象本身占用一块内存（堆内存），变量也占用一块内存，例如Objet obj = new Object();变量obj是一个内存，new Object()是另一个内存，此时，变量obj所对应的内存中存储的数值就是对象占用的那块内存的首地址。对于指向对象类型的变量，如果要比较两个变量是否指向同一个对象，即要看这两个变量所对应的内存中的数值是否相等，这时候就需要用==操作符进行比较。

equals方法是用于比较两个独立对象的内容是否相同，就好比去比较两个人的长相是否相同，它比较的两个对象是独立的。例如，对于下面的代码：

String a=new String("foo");
String b=new String("foo");

两条new语句创建了两个对象，然后用a,b这两个变量分别指向了其中一个对象，这是两个不同的对象，它们的首地址是不同的，即a和b中存储的数值是不相同的，所以，表达式a==b将返回false，而这两个对象中的内容是相同的，所以，表达式a.equals(b)将返回true。

在实际开发中，我们经常要比较传递进行来的字符串内容是否等，例如，String input = input.equals(“quit”)，许多人稍不注意就使用==进行比较了，这是错误的，随便从网上找几个项目实战的教学视频看看，里面就有大量这样的错误。记住，字符串的比较基本上都是使用equals方法。

如果一个类没有自己定义equals方法，那么它将继承Object类的equals方法，Object类的equals方法的实现代码如下：

boolean equals(Object o){
return this==o;
}

这说明，如果一个类没有自己定义equals方法，它默认的equals方法（从Object 类继承的）就是使用==操作符，也是在比较两个变量指向的对象是否是同一对象，这时候使用equals和使用==会得到同样的结果，如果比较的是两个独立的对象则总返回false。如果你编写的类希望能够比较该类创建的两个实例对象的内容是否相同，那么你必须覆盖equals方法，由你自己写代码来决定在什么情况即可认为两个对象的内容是相同的。
```



# 12.静态变量和实例变量的区别？

我的回答：静态变量是类变量，可以被每一个对象使用 实例变量是对象变量，~~不能被其他对象使用~~

```


在语法定义上的区别：静态变量前要加static关键字，而实例变量前则不加。

在程序运行时的区别：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。

例如，对于下面的程序，无论创建多少个实例对象，永远都只分配了一个staticVar变量，并且每创建一个实例对象，这个staticVar就会加1；但是，每创建一个实例对象，就会分配一个instanceVar，即可能分配多个instanceVar，并且每个instanceVar的值都只自加了1次。

public class VariantTest {
    public static int staticVar = 0;
    public int instanceVar = 0;

    public VariantTest() {
        staticVar++;
        instanceVar++;
        System.out.println("staticVar=" + staticVar + ",instanceVar=" + instanceVar);
    }
}
```

# 13.是否可以从一个static方法内部发出对非static方法的调用？

我的回答：可以

```
因为非static方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调用，而static方法调用时不需要创建对象，可以直接调用。也就是说，当一个static方法被调用时，可能还没有创建任何实例对象，如果从一个static方法中发出对非static方法的调用，那个非static方法是关联到哪个对象上的呢？这个逻辑无法成立，所以，一个static方法内部发出对非static方法的调用。
```

# 14.Integer与int的区别

我的回答：一个是包装类，一个是基础类

```
int是java提供的8种原始数据类型之一。Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。int的默认值为0，而Integer的默认值为null，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况，例如，要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer。在JSP开发中，Integer的默认为null，所以用el表达式在文本框中显示时，值为空白字符串，而int默认的默认值为0，所以用el表达式在文本框中显示时，结果为0，所以，int不适合作为web层的表单数据的类型。

在Hibernate中，如果将OID定义为Integer类型，那么Hibernate就可以根据其值是否为null而判断一个对象是否是临时的，如果将OID定义为了int类型，还需要在hbm映射文件中设置其unsaved-value属性为0。

另外，Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量。
```

# 15.Math.round(11.5)等于多少? Math.round(-11.5)等于多少?

我的回答：12   ~~-12~~

```
12  11 
Math类中提供了三个与取整有关的方法：ceil、floor、round，这些方法的作用与它们的英文名称的含义相对应，例如，ceil的英文意义是天花板，该方法就表示向上取整，Math.ceil(11.3)的结果为12,Math.ceil(-11.3)的结果是-11；floor的英文意义是地板，该方法就表示向下取整，Math.floor(11.6)的结果为11,Math.floor(-11.6)的结果是-12；最难掌握的是round方法，它表示“四舍五入”，算法为Math.floor(x+0.5)，即将原来的数字加上0.5后再向下取整，所以，Math.round(11.5)的结果为12，Math.round(-11.5)的结果为-11。
```

# 16.请说出作用域public，private，protected，以及不写时的区别

我的回答：public，所有包可用 private，只有自己类可用 protected，只有自己包可用

这四个作用域的可见范围如下表所示。

说明：如果在修饰的元素上面没有写任何访问修饰符，则表示friendly。

| 作用域         | 当前类 | 同一package | 子孙类 | 其他package |
| -------------- | ------ | ----------- | ------ | ----------- |
| public 公共    | √      | √           | √      | √           |
| protected 保护 | √      | √           | √      | ×           |
| friendly 友好  | √      | √           | ×      | ×           |
| private 私人   | √      | ×           | ×      | ×           |

备注：只要记住了有4种访问权限，4个访问范围，然后将全选和范围在水平和垂直方向上分别按排从小到大或从大到小的顺序排列，就很容易画出上面的图了。

# 17.Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型?

我的回答：重写和重载 重载可以与父方法的入参数不同 重写参数必须相同

```

Overload是重载的意思，Override是覆盖的意思，也就是重写。

重载Overload表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。

重写Override表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。子类覆盖父类的方法时，只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常，因为子类可以解决父类的一些问题，不能比父类有更多的问题。子类方法的访问权限只能比父类的更大，不能更小。如果父类的方法是private类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法。

至于Overloaded的方法是否可以改变返回值的类型这个问题，要看你倒底想问什么呢？这个题目很模糊。如果几个Overloaded的方法的参数列表不一样，它们的返回者类型当然也可以不一样。但我估计你想问的问题是：如果两个方法的参数列表完全一样，是否可以让它们的返回值不同来实现重载Overload。这是不行的，我们可以用反证法来说明这个问题，因为我们有时候调用一个方法时也可以不定义返回结果变量，即不要关心其返回结果，例如，我们调用map.remove(key)方法时，虽然remove方法有返回值，但是我们通常都不会定义接收返回结果的变量，这时候假设该类中有两个名称和参数列表完全相同的方法，仅仅是返回类型不同，java就无法确定编程者倒底是想调用哪个方法了，因为它无法通过返回结果类型来判断。

override可以翻译为覆盖，从字面就可以知道，它是覆盖了一个方法并且对其重写，以求达到不同的作用。对我们来说最熟悉的覆盖就是对接口方法的实现，在接口中一般只是对方法进行了声明，而我们在实现时，就需要实现接口声明的所有方法。除了这个典型的用法以外，我们在继承中也可能会在子类覆盖父类中的方法。在覆盖要注意以下的几点：

1）覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果；

2）覆盖的方法的返回值必须和被覆盖的方法的返回一致；

3）覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类；

4）被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。

overload对我们来说可能比较熟悉，可以翻译为重载，它是指我们可以定义一些名称相同的方法，通过定义不同的输入参数来区分这些方法，然后再调用时，JVM就会根据不同的参数样式，来选择合适的方法执行。在使用重载要注意以下的几点：

1）在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是fun(int,float)，但是不能为fun(int,int)）；

2）不能通过访问权限、返回类型、抛出的异常进行重载；

3）方法的异常类型和数目不会对重载造成影响；

4）对于继承来说，如果某一方法在父类中是访问权限是priavte，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。
```



# 18.构造器Constructor是否可被override?

我的回答：不行

```
构造器Constructor不能被继承，因此不能重写Override，但可以被重载Overload。
```

# 19.接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承具体类(concrete class)? 抽象类中是否可以有静态的main方法？

我的回答：不行，行，行，行

```
接口可以继承接口。抽象类可以实现(implements)接口，抽象类可以继承具体类。抽象类中可以有静态的main方法。

备注：只要明白了接口和抽象类的本质和作用，这些问题都很好回答，想想看，如果自己作为是java语言的设计者，是否会提供这样的支持，如果不提供的话，有什么理由吗？如果没有道理不提供，那答案就是肯定的了。

只有记住抽象类与普通类的唯一区别就是不能创建实例对象和允许有abstract方法。
```

20.写clone()方法时，通常都有一行代码，是什么？
我的回答：不会

```
clone 有缺省行为，super.clone();因为首先要把父类中的成员复制到位，然后才是复制自己的成员。
```

# 21.面向对象的特征有哪些方面

我的回答：封装 继承 多态

```
面向对象的编程语言有封装、继承 、抽象、多态等4个主要的特征。
```



# 22.java中实现多态的机制是什么？

我的回答：就是继承父类然后重写/重载父类的方法

```
靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。
```

# 23.abstract class和interface有什么区别?

我的回答：abstract 可以有抽象方法和普通方法

interface只能有普通方法

继承了abstract 必须实现抽象方法

继承interface不必实现抽象方法

```

1）抽象类可以有构造方法，接口中不能有构造方法。

2）抽象类中可以有普通成员变量，接口中没有普通成员变量

3）抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。

4） 抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然

eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。

5）抽象类中可以包含静态方法，接口中不能包含静态方法

6）抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。

7）一个类可以实现多个接口，但只能继承一个抽象类。
```

# 24.abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized?

我的回答： 可以

```
abstract的method 不可以是static的，因为抽象的方法是要被子类实现的，而static与子类扯不上关系！

native方法表示该方法要用另外一种依赖平台的编程语言实现的，不存在着被子类实现的问题，所以，它也不能是抽象的，不能与abstract混用。

关于synchronized与abstract合用的问题，我觉得也不行，因为在我几年的学习和开发中，从来没见到过这种情况，并且我觉得synchronized应该是作用在一个具体的方法上才有意义。而且，方法上的synchronized同步所使用的同步锁对象是this，而抽象方法上无法确定this是什么。
```

# 25.什么是内部类？Static Nested Class 和 Inner Class的不同。

我的回答： 不知到

```
内部类就是在一个类的内部定义的类，内部类中不能定义静态成员

内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，也可以定义在外部类的方法体中、
```

```
public class Outer {
    int out_x = 0;

    public void method() {
        //在方法体内部定义的内部类
        class Inner2 {
            public void method() {
                out_x = 3;
            }
        }
        Inner2 inner2 = new Inner2();
    }

    //在方法体外面定义的内部类
    public class Inner1 {

    }
}
```

```
在方法体外面定义的内部类的访问类型可以是public,protecte,默认的，private等4种类型，

创建内部类的实例对象时，一定要先创建外部类的实例对象，然后用这个外部类的实例对象去创建内部类的实例对象

在方法内部定义的内部类前面不能有访问类型修饰符，就好像方法中定义的局部变量一样，但这种内部类的前面可以使用final或abstract修饰符。这种内部类对其他类是不可见的其他类无法引用这种内部类，但是这种内部类创建的实例对象可以传递给其他类访问。这种内部类必须是先定义，后使用，即内部类的定义代码必须出现在使用该类之前，这与方法中的局部变量必须先定义后使用的道理也是一样的。这种内部类可以访问方法体中的局部变量，但是，该局部变量前必须加final修饰符。

由于static Nested Class不依赖于外部类的实例对象，所以，static Nested Class能访问外部类的非static成员变量。当在外部类中访问Static Nested Class时，可以直接使用Static Nested Class的名字，而不需要加上外部类的名字了，在Static Nested Class中也可以直接引用外部类的static的成员变量，不需要加上外部类的名字。

在静态方法中定义的内部类也是Static Nested Class，这时候不能在类前面加static关键字，静态方法中的Static Nested Class与普通方法中的内部类的应用方式很相似，它除了可以直接访问外部类中的static的成员变量，还可以访问静态方法中的局部变量，但是，该局部变量前必须加final修饰符。
```

# 26.内部类可以引用它的包含类的成员吗？有没有什么限制？

我的回答：可以引用

```
如果不是静态内部类，那没有什么限制！

如果把静态嵌套类当作内部类的一种特例，那在这种情况下不可以访问外部类的普通成员变量，而只能访问外部类中的静态成员，例如，下面的代码：
```

```
class Outer {
    static int x;

    static class Inner {
        void test() {
            syso(x);
        }
    }
}
```

# 27.Anonymous Inner Class (匿名内部类) 是否可以extends(继承)其它类，是否可以implements(实现)interface(接口)?

我的回答：不能，不能

```
可以继承其他类或实现其他接口。不仅是可以，而是必须!
```

# 28.super.getClass()方法调用 下面程序的输出结果是多少？

```
import java.util.Date;

public class Test extends Date {
	public static void main(String[] args) {
		new Test().test();
	}
	
	public void test() {
		System.out.println(super.getClass().getName());
	}
}
```

我的回答：调用父类的getClass()方法

```
在test方法中，直接调用getClass().getName()方法，返回的是Test类名。由于getClass()在Object类中定义成了final，子类不能覆盖该方法，所以，在test方法中调用getClass().getName()方法，其实就是在调用从父类继承的getClass()方法，等效于调用super.getClass().getName()方法，所以，super.getClass().getName()方法返回的也应该是Test。

如果想得到父类的名称，应该用如下代码：
getClass().getSuperClass().getName();

```

# 29.String是最基本的数据类型吗?

我的回答：不是

```
基本数据类型包括byte、int、char、long、float、double、boolean和short。
```

# 30.String s = "Hello";s = s + " world!";这两行代码执行后，原始的String对象中的内容到底变了没有？

我的回答：没有变，而是生成了一个新的对象

```
因为String被设计成不可变(immutable)类，所以它的所有对象都是不可变对象。在这段代码中，s原先指向一个String对象，内容是 "Hello"，然后我们对s进行了+操作，那么s所指向的那个对象是否发生了改变呢？答案是没有。这时，s不指向原来那个对象了，而指向了另一个 String对象，内容为"Hello world!"，原来那个对象还存在于内存之中，只是s这个引用变量不再指向它了。
```

# 31.是否可以继承String类?

我的回答：不能应为是final类

# 32.String s = new String("xyz");创建了几个String Object? 二者之间有什么区别？

我的回答：一个，不知道

```
两个或一个，”xyz”对应一个对象，这个对象放在字符串常量缓冲区，常量”xyz”不管出现多少遍，都是缓冲区中的那一个。New String每写一遍，就创建一个新的对象，它一句那个常量”xyz”对象的内容来创建出一个新String对象。如果以前就用过’xyz’，这句代表就不会创建”xyz”自己了，直接从缓冲区拿。
```

# 33.String 和StringBuffer的区别

我的回答：String 每次对字符串的操作都会创建一个新的对象StringBuffer不会创建新的对象

```
JAVA平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符的字符数据。这个String类提供了数值不可改变的字符串。而这个StringBuffer类提供的字符串进行修改。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用StringBuffers来动态构造字符数据。另外，String实现了equals方法，new String(“abc”).equals(new String(“abc”)的结果为true,而StringBuffer没有实现equals方法，所以，new StringBuffer(“abc”).equals(new StringBuffer(“abc”)的结果为false。
```

# 34.如何把一段逗号分割的字符串转换成一个数组?

我的回答：split(',')

```
1. String [] result = orgStr.split(",");

2.
StringTokenizer tokener = StringTokenizer(orgStr,",");
String [] result = new String[tokener .countTokens()];
Int i=0;
while(tokener.hasNext(){result[i++]=toker.nextToken();}
```

# 35.数组有没有length()这个方法? String有没有length()这个方法？

我的回答：数组是size String有

```
数组没有length()这个方法，有length的属性。String有有length()这个方法。
```

# 36.下面这条语句一共创建了多少个对象? String s="a"+"b"+"c"+"d";

我的回答：一个

```
对于如下代码：

String s1 = "a";
String s2 = s1 + "b";
String s3 = "a" + "b";
System.out.println(s2 == "ab");
System.out.println(s3 == "ab");

第一条语句打印的结果为false，第二条语句打印的结果为true，这说明javac编译可以对字符串常量直接相加的表达式进行优化，不必要等到运行期去进行加法运算处理，而是在编译时去掉其中的加号，直接将其编译成一个这些常量相连的结果。

题目中的第一行代码被编译器在编译时优化后，相当于直接定义了一个”abcd”的字符串，所以，上面的代码应该只创建了一个String对象。写如下两行代码，

String s = "a" + "b" + "c" + "d";
System.out.println(s == "abcd");

最终打印的结果应该为true。
```

# 37.try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后?

我的回答：会被执行，再return前执行

```
但往更细地说，我的答案是在return中间执行，请看下面程序代码的运行结果：.
public class Test {

    public static void main(String[] args) {
        System.out.println(Test.test());
    }

    static int test() {
        int x = 1;
        try {
            return x;
        } finally {
            ++x;
        }
    }
}

---------执行结果 ---------
1
--------------------------
try块中有一个return语句时，紧跟在try块后的finally块中的代码仍然会被执行**‌。具体来说，当程序执行到try块中的return语句时，并不会立即返回，而是先将return语句的结果保存起来，然后执行finally块中的代码。finally块执行完毕后，再返回之前保存的结果‌12。

### finally块执行的具体过程

1.保存返回值：当try块中的return语句被执行时，程序会先将返回值保存起来，但不会立即返回。
2.执行finally块：接着程序会跳转到finally块执行其中的代码。如果在finally块中修改了返回值，这些修改不会影响try块中return语句的最终结果，因为返回值在finally块执行之前已经被保存
3.返回保存的结果：finally块执行完毕后，程序会从之前保存的位置继续返回，返回try块中保存的结果‌12。

```

# 38.下面的程序代码输出的结果是多少？

```
public class SmallT {
    public static void main(String args[]) {
        SmallT t = new SmallT();
        int b = t.get();
        System.out.println(b);
    }

    public int get() {
        try {
            return 1;
        } finally {
            return 2;
        }
    }
}
```

我的回答：2

```
try中的return语句调用的函数先于finally中调用的函数执行，也就是说return语句先执行，finally语句后执行，所以，返回的结果是2。Return并不是让函数马上返回，而是return语句执行后，将把返回结果放置进函数栈中，此时函数并不是马上返回，它要执行finally语句后才真正开始返回。
```

# 39.final, finally, finalize的区别。

我的回答： final是修饰符，finally是保留字，用于处理异常发生后最终要做的事情，finalize 不知道。

```
final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。

内部类要访问局部变量，局部变量必须定义成final类型。

finally是异常处理语句结构的一部分，表示总是执行。

finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。JVM不保证此方法总被调用
```

# 40.运行时异常与一般异常有何异同？

我的回答：允许时异常只有代码运行才会被发现，可以通过编译，一般异常无法通过编译

```
异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。
```

41.error和exception有什么区别?
42.Java中的异常处理机制的简单原理和应用。
43.请写出你最常见到的5个runtime exception。
44.java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？
45.sleep() 和 wait() 有什么区别?
46.同步和异步有何异同，在什么情况下分别使用他们？举例说明。
47.多线程有几种实现方法?同步有几种实现方法?
48.启动一个线程是用run()还是start()？
49.当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?
50.线程的基本概念、线程的基本状态以及状态之间的关系。
51.简述synchronized和java.util.concurrent.locks.Lock的异同 ？
51.简述 synchronized 和 java.util.concurrent.locks.Lock 的异同 ？
52.设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。写出程序。
53.子线程循环10次，接着主线程循环100，接着又回到子线程循环10次，接着再回到主线程又循环100，如此循环50次，请写出程序。
54.Collection框架中实现比较要实现什么接口
55.ArrayList和Vector的区别
56.HashMap和Hashtable的区别  56.HashMap 和 Hashtable 的区别
57.List 和 Map 区别?
58.List, Set, Map是否继承自Collection接口?
59.List、Map、Set三个接口，存取元素时，各有什么特点？
60.说出ArrayList,Vector, LinkedList的存储性能和特性
61.去掉一个Vector集合中重复的元素
62.Collection 和 Collections的区别。
62.Collection 和 Collections 的区别。
63.Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()? 它们有何区别?
64.你所知道的集合类都有哪些？主要方法？
65.两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对?
66.TreeSet里面放对象，如果同时放入了父类和子类的实例对象，那比较时使用的是父类的compareTo方法，还是使用的子类的compareTo方法，还是抛异常！
67.说出一些常用的类，包，接口，请各举5个。
68.java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？
69.字节流与字符流的区别
70.什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用。
71.描述一下JVM加载class文件的原理机制?
72.heap和stack有什么区别。
73.GC是什么? 为什么要有GC?
74.垃圾回收的优点和原理。并考虑2种回收机制。
75.垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？
76.什么时候用assert。
77.java中会存在内存泄漏吗，请简单描述。
78.能不能自己写个类，也叫java.lang.String？
79.获得一个类的类对象有哪些方式？
80.Java代码查错